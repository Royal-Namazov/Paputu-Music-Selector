<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Music Segment Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #121212;
      color: white;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    button {
      background-color: #1DB954;
      border: none;
      color: white;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 30px;
      cursor: pointer;
      margin: 20px 0;
      font-weight: bold;
    }
    #nowPlaying {
      font-size: 24px;
      margin: 20px 0;
      min-height: 60px;
    }
    #timer {
      font-family: monospace;
      font-size: 20px;
    }
    #tourInfo {
      font-size: 18px;
      color: #1DB954;
      margin: 10px 0;
    }
    .volume-control {
      margin: 20px auto;
      width: 200px;
    }
    .segment-info {
      margin-top: 20px;
      font-size: 16px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <h1>ðŸŽµ Advanced Music Segment Player</h1>
  <div id="tourInfo">Initializing...</div>
  <button id="playButton">NEXT SEGMENT</button>
  <div id="nowPlaying">Loading player...</div>
  <div id="timer">00:00 / 01:00</div>
  <div class="segment-info" id="segmentInfo">Segment type: -</div>
  
  <div class="volume-control">
    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.7">
  </div>

  <!-- Audio elements pool -->
  <audio id="player1"></audio>
  <audio id="player2"></audio>
  
  <script>
    // Configuration
    const SEGMENT_LENGTH = 60; // 1 minute segments
    const TRACK_COUNT = 29; // Number of music tracks
    const SEGMENT_TYPES = ['first', 'middle-first', 'middle-last', 'last'];
    
    // DOM elements
    const playButton = document.getElementById('playButton');
    const nowPlaying = document.getElementById('nowPlaying');
    const timer = document.getElementById('timer');
    const volumeControl = document.getElementById('volume');
    const tourInfo = document.getElementById('tourInfo');
    const segmentInfo = document.getElementById('segmentInfo');
    
    // Audio elements
    const players = [
      document.getElementById('player1'),
      document.getElementById('player2')
    ];
    
    // State
    const state = {
      currentPlayer: 0,
      nextPlayer: 1,
      currentTrack: null,
      currentSegment: 0,
      totalSegments: 0,
      elapsed: 0,
      timerInterval: null,
      currentTour: 0,
      usedSegments: {}, // Track used segments per song
      remainingTracks: [],
      segmentHistory: {} // Track segment history per song
    };
    
    // Initialize
    function init() {
      // Set initial volume
      players.forEach(p => p.volume = volumeControl.value);
      volumeControl.addEventListener('input', () => {
        players.forEach(p => p.volume = volumeControl.value);
      });
      
      // Initialize segment history
      for (let i = 1; i <= TRACK_COUNT; i++) {
        state.segmentHistory[i] = [];
      }
      
      // Start first tour
      startNewTour();
      
      // Button handler
      playButton.addEventListener('click', playNextSegment);
    }
    
    function startNewTour() {
      state.currentTour++;
      state.remainingTracks = shuffleArray([...Array(TRACK_COUNT).keys()].map(i => i + 1));
      tourInfo.textContent = `Tour ${state.currentTour} of ${TRACK_COUNT} tracks`;
      
      // Preload first track
      loadNextTrack();
    }
    
    function loadNextTrack() {
      if (state.remainingTracks.length === 0) {
        startNewTour();
        return;
      }
      
      state.currentTrack = state.remainingTracks.pop();
      state.currentSegment = 0;
      
      const player = players[state.nextPlayer];
      player.src = `music/music${state.currentTrack}.mp3`;
      player.load();
      
      player.addEventListener('canplaythrough', () => {
        state.totalSegments = Math.floor(player.duration / SEGMENT_LENGTH);
        
        // If this is the active player, start playback
        if (player === players[state.currentPlayer]) {
          playCurrentSegment();
        }
      }, { once: true });
      
      player.addEventListener('error', () => {
        console.error(`Error loading track ${state.currentTrack}`);
        loadNextTrack();
      }, { once: true });
    }
    
    function playCurrentSegment() {
      const player = players[state.currentPlayer];
      const duration = player.duration;
      
      // Get an unused segment for this track
      const segmentData = getNextSegment(state.currentTrack, duration);
      state.currentSegment++;
      
      // Play the segment
      player.currentTime = segmentData.startTime;
      player.play()
        .then(() => {
          updateUI(segmentData.type);
          startTimer();
          
          // Preload next track in background
          if (state.remainingTracks.length > 0) {
            loadNextTrack();
          }
        })
        .catch(err => {
          console.error("Playback error:", err);
          playNextSegment();
        });
    }
    
    function getNextSegment(trackNumber, duration) {
      const availableSegments = [];
      const totalPossible = Math.floor(duration / SEGMENT_LENGTH);
      
      // First segment (0-60s)
      if (!state.segmentHistory[trackNumber].includes('first')) {
        availableSegments.push({
          type: 'first',
          startTime: 0
        });
      }
      
      // Last segment (last 60s)
      if (!state.segmentHistory[trackNumber].includes('last')) {
        const lastStart = Math.max(0, duration - SEGMENT_LENGTH);
        availableSegments.push({
          type: 'last',
          startTime: lastStart
        });
      }
      
      // Middle segments
      if (totalPossible > 2) {
        const middlePoint = Math.floor(duration / 2);
        
        // Middle-first (middle-60s)
        if (!state.segmentHistory[trackNumber].includes('middle-first')) {
          availableSegments.push({
            type: 'middle-first',
            startTime: Math.max(0, middlePoint - SEGMENT_LENGTH)
          });
        }
        
        // Middle-last (middle+60s)
        if (!state.SegmentHistory[trackNumber].includes('middle-last')) {
          availableSegments.push({
            type: 'middle-last',
            startTime: Math.min(middlePoint, duration - SEGMENT_LENGTH)
          });
        }
      }
      
      // If no special segments left, pick a random unused one
      if (availableSegments.length === 0) {
        const allPossible = Math.floor(duration / SEGMENT_LENGTH);
        const usedSegments = state.usedSegments[trackNumber] || new Set();
        
        let randomSegment;
        do {
          randomSegment = Math.floor(Math.random() * allPossible);
        } while (usedSegments.has(randomSegment) && usedSegments.size < allPossible);
        
        if (!usedSegments.has(randomSegment)) {
          usedSegments.add(randomSegment);
          state.usedSegments[trackNumber] = usedSegments;
          
          return {
            type: 'random',
            startTime: randomSegment * SEGMENT_LENGTH
          };
        }
      }
      
      // Pick a random available special segment
      const segment = availableSegments[Math.floor(Math.random() * availableSegments.length)];
      state.segmentHistory[trackNumber].push(segment.type);
      return segment;
    }
    
    function playNextSegment() {
      clearInterval(state.timerInterval);
      
      const player = players[state.currentPlayer];
      const duration = player.duration;
      const currentTime = player.currentTime;
      
      // If we've played less than segment length, continue current segment
      if (state.elapsed < SEGMENT_LENGTH && currentTime + (SEGMENT_LENGTH - state.elapsed) < duration) {
        player.currentTime = currentTime + (SEGMENT_LENGTH - state.elapsed);
        state.elapsed = 0;
        startTimer();
        return;
      }
      
      // Switch players for next track
      [state.currentPlayer, state.nextPlayer] = [state.nextPlayer, state.currentPlayer];
      playCurrentSegment();
    }
    
    function startTimer() {
      state.elapsed = 0;
      clearInterval(state.timerInterval);
      updateTimerDisplay();
      
      state.timerInterval = setInterval(() => {
        state.elapsed++;
        updateTimerDisplay();
        
        if (state.elapsed >= SEGMENT_LENGTH) {
          playNextSegment();
        }
      }, 1000);
    }
    
    function updateTimerDisplay() {
      timer.textContent = `${String(Math.floor(state.elapsed / 60)).padStart(2, '0')}:${String(state.elapsed % 60).padStart(2, '0')} / 01:00`;
    }
    
    function updateUI(segmentType) {
      nowPlaying.textContent = `Playing TRACK ${state.currentTrack} (Segment ${state.currentSegment})`;
      segmentInfo.textContent = `Segment type: ${segmentType}`;
    }
    
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    
    // Start the player
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
